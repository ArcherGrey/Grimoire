# XSS

::: tip 概念

Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。

:::

~~为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。~~

XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。

不仅仅是业务上的“用户的 `UGC` 内容”可以进行注入，包括 `URL` 上的参数等都可以是攻击的来源。在处理输入时，以下内容都不可信：

- 来自用户的 `UGC` 信息
- 来自第三方的链接
- `URL` 参数
- `POST` 参数
- `Referer` （可能来自不可信的来源）
- `Cookie` （可能来自其他子域注入）

分类

|    类型    |         存储区          |     插入点      |
| :--------: | :---------------------: | :-------------: |
| 存储型 XSS |       后端数据库        |      HTML       |
| 反射型 XSS |           URL           |      HTML       |
| DOM 型 XSS | 后端数据库/前端存储/URL | 前端 JavaScript |

存储型 `XSS` 的攻击步骤：

1. 攻击者将恶意代码提交到目标网站的数据库中。
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 `HTML` 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。

反射型 `XSS` 的攻击步骤：

1. 攻击者构造出特殊的 `URL`，其中包含恶意代码。
2. 用户打开带有恶意代码的 `URL` 时，网站服务端将恶意代码从 `URL` 中取出，拼接在 `HTML` 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

反射型 `XSS` 跟存储型 `XSS` 的区别是：存储型 `XSS` 的恶意代码存在数据库里，反射型 `XSS` 的恶意代码存在 `URL` 里。

反射型 `XSS` 漏洞常见于通过 `URL` 传递参数的功能，如网站搜索、跳转等。
由于需要用户主动打开恶意的 `URL` 才能生效，攻击者往往会结合多种手段诱导用户点击。
`POST` 的内容也可以触发反射型 `XSS`，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。

`DOM` 型 `XSS` 的攻击步骤：

1. 攻击者构造出特殊的 `URL`，其中包含恶意代码。
2. 用户打开带有恶意代码的 `URL`。
3. 用户浏览器接收到响应后解析执行，前端 `JavaScript` 取出 `URL` 中的恶意代码并执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

`DOM` 型 `XSS` 跟前两种 `XSS` 的区别：`DOM` 型 `XSS` 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 `JavaScript` 自身的安全漏洞，而其他两种 `XSS` 都属于服务端的安全漏洞。

## 预防

`XSS` 攻击有两大要素：

- 攻击者提交恶意代码
- 浏览器执行恶意代码
  - 防止 `html` 注入
  - 防止 `js` 执行恶意代码

预防存储型和反射型 `XSS` 攻击:

- 纯前端渲染，把代码和数据分离
  1. 浏览器先加载一个静态 `HTML`，此 `HTML` 中不包含任何跟业务相关的数据。
  2. 然后浏览器执行 `HTML` 中的 `JavaScript`。
  3. `JavaScript` 通过 `Ajax` 加载业务数据，调用 `DOM API` 更新到页面上。
- 对 `html` 充分转义

预防 `DOM` 型 `XSS` 攻击:

- 在使用 `.innerHTML、.outerHTML、document.write()` 时要特别小心，不要把不可信的数据作为 `HTML` 插到页面上，而应尽量使用 `.textContent、.setAttribute()` 等。
- 如果用 `Vue/React` 技术栈，并且不使用 `v-html/dangerouslySetInnerHTML` 功能，就在前端 `render` 阶段避免 `innerHTML、outerHTML` 的 `XSS` 隐患。
- `DOM` 中的内联事件监听器，如 `location、onclick、onerror、onload、onmouseover` 等，`<a>` 标签的 `href` 属性，`JavaScript` 的 `eval()、setTimeout()、setInterval()` 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 `API`，很容易产生安全隐患，请务必避免。

## 通用方案

`Content Security Policy`
严格的 `CSP` 在 `XSS` 的防范中可以起到以下的作用：

- 禁止加载外域代码，防止复杂的攻击逻辑。
- 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。
- 禁止内联脚本执行（规则较严格，目前发现 `GitHub` 使用）。
- 禁止未授权的脚本执行（新特性，`Google Map` 移动版在使用）。
- 合理使用上报可以及时发现 `XSS`，利于尽快修复问题。

输入内容长度控制
对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 `XSS` 发生，但可以增加 `XSS` 攻击的难度。

其他安全措施

- `HTTP-only Cookie`: 禁止 `JavaScript` 读取某些敏感 `Cookie`，攻击者完成 `XSS` 注入后也无法窃取此 `Cookie`。
- 验证码：防止脚本冒充用户提交危险操作。
