(window.webpackJsonp=window.webpackJsonp||[]).push([[257],{655:function(v,_,e){"use strict";e.r(_);var t=e(19),c=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"computed"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed"}},[v._v("#")]),v._v(" "),e("code",[v._v("computed")])]),v._v(" "),e("h2",{attrs:{id:"和-watch-差异"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#和-watch-差异"}},[v._v("#")]),v._v(" 和 "),e("code",[v._v("watch")]),v._v(" 差异")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("computed")]),v._v(" 是生成一个新的属性挂载到实例上，"),e("code",[v._v("watch")]),v._v(" 是监听已经存在且挂载到实例上的数据，所以 "),e("code",[v._v("watch")]),v._v(" 也可以监听 "),e("code",[v._v("computed")]),v._v(" 属性变化")]),v._v(" "),e("li",[e("code",[v._v("computed")]),v._v(" 具有缓存，只有依赖变化才会重新计算")]),v._v(" "),e("li",[e("code",[v._v("computed")]),v._v(" 适合一个数据被多个数据影响，"),e("code",[v._v("watch")]),v._v(" 适合要给数据影响多个数据")])]),v._v(" "),e("h2",{attrs:{id:"原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[v._v("#")]),v._v(" 原理")]),v._v(" "),e("ul",[e("li",[v._v("依赖变化，修改脏数据标志为真，但不会立即重新计算，只有在访问计算属性的时候，才会重新计算或读取缓存，有懒计算特性")])]),v._v(" "),e("h2",{attrs:{id:"流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#流程"}},[v._v("#")]),v._v(" 流程")]),v._v(" "),e("ol",[e("li",[v._v("响应式的值 "),e("code",[v._v("count")]),v._v(" 更新")]),v._v(" "),e("li",[v._v("同时通知 "),e("code",[v._v("computed watcher")]),v._v(" 和 渲染 "),e("code",[v._v("watcher")]),v._v(" 更新")]),v._v(" "),e("li",[e("code",[v._v("computed watcher")]),v._v(" 把 "),e("code",[v._v("dirty")]),v._v(" 设置为 "),e("code",[v._v("true")])]),v._v(" "),e("li",[v._v("视图渲染读取到 "),e("code",[v._v("computed")]),v._v(" 的值，由于 "),e("code",[v._v("dirty")]),v._v(" 所以 "),e("code",[v._v("computed watcher")]),v._v(" 重新求值。")])]),v._v(" "),e("p",[v._v("不缓存：")]),v._v(" "),e("ol",[e("li",[e("code",[v._v("count")]),v._v(" 改变，先通知到 计算 "),e("code",[v._v("watcher")]),v._v(" 更新，设置 "),e("code",[v._v("dirty = true")])]),v._v(" "),e("li",[v._v("再通知到 渲染 "),e("code",[v._v("watcher")]),v._v(" 更新，视图重新渲染的时候去 计算 "),e("code",[v._v("watcher")]),v._v(" 中读取值，发现 "),e("code",[v._v("dirty")]),v._v(" 是 "),e("code",[v._v("true")]),v._v("，重新执行用户传入的函数求值。")])]),v._v(" "),e("p",[v._v("缓存：")]),v._v(" "),e("ol",[e("li",[e("code",[v._v("other")]),v._v(" 改变，直接通知 渲染 "),e("code",[v._v("watcher")]),v._v(" 更新。")]),v._v(" "),e("li",[v._v("视图重新渲染的时候去 计算 "),e("code",[v._v("watcher")]),v._v(" 中读取值，发现 "),e("code",[v._v("dirty")]),v._v(" 为 "),e("code",[v._v("false")]),v._v("，直接用缓存值 "),e("code",[v._v("watcher.value")]),v._v("，不执行用户传入的函数求值。")])])])}),[],!1,null,null,null);_.default=c.exports}}]);